# GoF의 디자인패턴

## 생성패턴

### 1. 추상 팩토리

#### 결과

1. 구체적인 클래스 분리
2. 제품군을 쉽게 대체 가능하도록 해줌
3. 제품 사이의 일관성 증진
4. 새로운 종류의 제품을 제공하기 어려움

#### 구현

1. 팩토리를 단일체로 정의
2. 제품을 생성
3. 확장 가능한 팩토리들을 정의

Kit 라는 접미어를 사용해서 추상 팩토리 클래스임을 표시

### 2. 빌더

#### 결과

1. 제품에 대한 내부 표현을 다양하게 변화할 수 있음
2. 생성과 표현에 필요한 코드를 분리
3. 복합 객체를 생성하는 절차를 좀더 세밀하게 나눌 수 있음

#### 구현

1. 조합과 구축에 필요한 인터페이스 정의
2. 제품에 대한 추상 클래스는 필요 없음
3. Builder에 있는 메서드에 대해서는 구현을 제공하지 않는게 일반적

### 3. 팩토리 메서드

#### 결과

1. 서브클래스에 대  훅\(hook\) 메서드를 제공
2. 병렬적인 클래스 계통을 연결하는 역할 담당

#### 구현

1. 구현 방법이 크게 두 가지
   1. Creator 클래스를 추상 클래스로 정의하고 정의한 팩토리 메서드에 대한 구현은 제공하지 않는 경우
   2. Creator가 구체 클래스이고 팩토리 메서드에 대한 기본 구현을 제공하는 경우
2. 팩토리 메서드를 매개변수화함
3. 언어마다 구현 방법이 조금 다를 수 있음
4. 템플릿을 사용하여 서브클래싱을 피함

다른 이름은 가상 생성자\(Virtual Constructor\)

### 4. 원형

원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체 생성

#### 결과

1. 런타임에 새로운 제품을 추가하고 삭제 가능
2. 값들을 다양화함으로써 새로운 객체를 명세
3. 구조를 다양화함으로써 새로운 객체를 명세
4. 서브클래스의 수를 줄임
5. 동적으로 클래스에 따라 응용프로그램을 설정할 수 있음

#### 구현

1. 원형 관리자를 사용
2. Clone\(\) 연산을 구현
3. Clone을 초기화

### 5. 단일체\(Singleton\)

오직 한 개의 클래스 인스턴스만을 갖도록 보장 및 전역적인 접근점을 제공

#### 결과

1. 유일하게 존재하는 인스턴스로의 접근을 통제
2. 이름 공간\(name space\)을 좁힘
3. 연산 및 표현의 정제를 허용
4. 인스턴스의 개수를 변경하기 자유로움
5. 클래스 연산을 사용하는 것보다 훨씬 유연한 방법

#### 구현

1. 인스턴스가 유일해야 함을 보장
2. Singleton 클래스를 서브클래싱함

## 구조패턴

### 1. 적응자\(Adapter\)

클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킴

서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킴

#### 고려해야할 추가 사항들

1. Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되는지
2. 대체 가능\(Pluggable\) 적응자
3. 양방향 적응자를 통한 투명성 제공

#### 구

1. 클래스 적응자를 C++로 구현
2. 대체 가능 적응자
   1. 추상 연산을 사용하는 방법
   2. 위임 객체를 사용하는 방법
   3. 매개변수화된 적응자를 사용하는 방

### 가교\(Bridge\)

#### 다른 이름

핸들/구현부\(Handle/Body\)

#### 결과

1. 인터페이스와 구현 분리
2. Abstraction과 Implementor를 독립적으로 확장 가능
3. 구현 세부 사항을 사용자에게서 숨기기

#### 구현

1. Implementor 하나만 둔다
2. 정확한 Implementor 객체를 생성
3. Implementor를 공
4. 다중 상속을 이용

### 복합체

부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성

사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

#### 결과

1. 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의
2. 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문에 사용자 코드가 단순해짐
3. 새로운 종류의 구성요소를 쉽게 추가 가능
4. 설계가 지나치게 범용성을 많이 가짐

#### 구현

1. 포함 객체에 대한 명확한 참조자
2. 구성요소 공유
3. Component 인터페이스를 최대화
4. 자식을 관리하는 연산 선언
5. Component가 Component의 리스트를 구현\(자식의 개수가 어느 정도 될 떄만 가치를 지님\)
6. 자식 사이의 순서 정하기
7. 성능 개선을 위한 캐싱\(caching\)
8. 구성요소를 삭제하는 책임\(가비지 컬렉션의 기능을 제공하지 않는 경우 Composite클래스가 책임\)
9. 구성요소를 저장하기 위한 가장 적당한 데이터 구조는 효율적인 데이터 구조를 선택

### 장식자\(Decorator\)

#### 다른 이름

랩퍼\(Wrapper\)

#### 활용성

* 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가하기 위해 사용
* 제거될 수 있는 책임에 대해 사용
* 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용

#### 결과

1. 단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있음
2. 클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있음
3. 장식자와 해당 그 장식자의 구성요소가 동일한 것은 아님
4. 장식자를 사용함으로써 작은 규모의 객체들이 많이 생김

#### 구현

1. 인터페이스 일치
2. 추상 클래스로 정의되는 Decorator 클래스 생략
3. Component 클래스는 가벼운 무게 유지
4. 객체의 겉포장을 변경할지 속을 변경할지 선택

### 퍼사드\(Facade\)

한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴

서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의

#### 결과

1. 서브시스템의 구성요소를 보호할 수 있음
2. 서브 시스템과 사용자 코드 간의 결합도를 더욱 약하게 만듬
3. 응용프로그램 쪽에서 서브 시스템 클래스를 사용하는 것을 완전히 막지는 않아서 Facade를 사용할지 서브시스템 클래스를 직접 사용할지 결정 가능

#### 구현

1. 사용자와 서브시스템 간의 결합도 줄이기
2. 서브시스템 클래스 중 공개할 것과 감출 것을 정의

### 플라이급\(Flyweight\)

공유를 통해 많은 수의 소립 객체들을 효과적으로 지원

#### 활용성

* 응용프로그램이 대량의 객체를 사용해야 할 때
* 객체의 수가 너무 많아져서 저장 비용이 너무 높아질 때
* 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
* 부가적인 속성들을 제거한 후 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 때
* 본질이 달랐던 것은 아닐 때(부가적인 속성 때문에 다른 객체로 간주한 경우)
* 응용 프로그램이 객체의 정체성에 의존하지 않을 때

#### 결과

1. 공유해야 하는 인스턴스의 전체 수를 줄일 수 있음
2. 객체별 본질적 상태의 양을 줄일 수 있음
3. 부가적인 상태는 연산되거나 저장될 수 있음

#### 구현

1. 부가적인 상태를 제외
2. 공유할 객체를 관리

### 프록시\(Proxy\)

다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둠

#### 다른 이름

대리자(Surrogate)

#### 활용성

1. 원격지 프록시
2. 가상 프록시
3. 보호용 프록시
4. 스마트 참조자(스마트 포인터)

#### 결과

1. 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있음
2. 가상 프록시는 요구에 따라 객체를 생성하는 등 처리를 최적화 가능
3. 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임짐

#### 구현

1. C++에서는 멤버 접근 연산자를 오버로드
2. 스몰토크에 정의된 doesNotUnderstand를 사용하는 방법
3. Proxy가 항상 자신이 상대할 실제 대상을 알 필요는 없음(단, RealSubject의 인스턴스를 생성해야하는 시점에는 어떤 클래스의 인스턴스를 생성해야하는지 알아야함)

## 행동 패턴

어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은가, 알고리즘을 어느 객체에 정의하는 것이 좋은가 등을 다룸

### 책임 연쇄\(Chain of responsibility\)

메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴

### 활용성

* 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤것이 선행자인지 모를 때, 처리자가 자동으로 확정되어야 함
* 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
* 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

### 결과

1. 객체 간의 행동적 결합도가 적어짐
2. 객체에게 책임을 할당하는 데 유연성을 높일 수 있음
3. 메시지 수신이 보장되지는 않음

### 구현

1. 후속 처리자들의 연결 고리 구현하기
2. 후속 처리자 연결하기
3. 처리 요청의 표현부를 정의함
4. 스몰토크를 쓸 때 자동 전달 기능을 이용함

### 명령\(Command\)

요청 자체를 캡슐화하는 것
요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원

#### 다른 이름

작동(Action), 트랜잭션(Transaction)

#### 활용성

* 수행할 동작을 객체로 매개변수화하고자 할 때
* 서로 다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을 때
* 실챙 취소 기능을 지원하고 싶을 때
* 시스템이 고장 났을 때 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때
* 기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때

#### 결과

1. Command는 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리함
2. Command는 일급 클래스 
다른 객체와 같은 방식으로 조작되고 확장 할 수 있음
3. 새로운 Command에 객체를 추가하기 쉬움
기존 클래스를 변경할 필요없이 단지 새로운 명령어에 대응하는 클래스만 정의하면 됨

#### 구현

1. 명령 패턴은 수신 개체를 동적으로 발견할 수 있는 능력을 지녀야 함
2. 취소(undo) 및 반복(redo) 연산 지원하기
3. 취소를 진행하는 도중 오류가 누적되는 것 피하기
4. C++ 템플릿 사용하기

### 해석자\(Interpreter\)

어떤 언어에 대해, 그 언어의 문법에 대한 표현을 정의하면서 그것(표현)을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의

#### 활용성

해석자 패턴이 가장 잘 먹힐 때

* 정의할 언어의 문법이 간단한 경우
* 효율성을 고려할 사항이 아닌 경우

#### 결과

1. 문법의 변경과 확장이 쉬움
2. 문법의 구현이 용이
3. 복잡한 문법은 관리하기 어려움
4. 표현식을 해석하는 새로운 방법을 추가 가능

#### 구현

1. 추상 구문 트리를 생성
2. Interpret() 연산을 정의
3. 플라이급 패턴을 적용하여 단말 기호를 공유

### 반복자\(Iterator\)

내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할수 있는 방법을 제공

#### 다른 이름

커서(Cursor)

#### 활용성

이런 목적으로 사용

* 객체 내부 표현 방식을 모르고도 집합 객체의 각 원소들에 접근하고 싶을 때
* 집합 객체를 순회하는 다양한 방법을 지원하고 싶을 때
* 서로 다른 집합 객체 구조에 대해서도 동일한 방법으로 순회하고 싶을 때

#### 결과

1. 집합 객체의 다양한 순회 방법을 제공
2. Iterator는 Aggregate 클래스의 인터페이스를 단순화함
3. 집합 객체에 따라 하나 이상의 순회 방법이 제공될 수 있음

#### 구현

1. 어떤 부분에서 반복을 제어할 것인지 결정(사용자가 반복 제어 - 외부 반복자, 반복자 자신이 제어를 담당 - 내부 반복자)
2. 순회 알고리즘을 어디에서 정의할 것인지 결정
3. 집합 객체를 복사해 두었다가 그 복사본을 순회하도록 제작, 순회 중에는 삽입이나 삭제가 일어나지 않도록 제작하고 집합 객체를 복사하는 방법을 사용하지 않아야함
4. 추가적으로 필요한 반복자 연산을 제작
5. C++에서 다형성을 지닌 반복자를 이용은 필요할 때만
6. 반복자와 집합 객체 간의 결합도가 매우 커졌을 때 반복자를 집합 객체의 프렌드로 정의함으로써 특수한 접근 권한을 가짐
7. 외부 반복자는 재귀적 합성 구조를 처리하도록 구현하기 어렵기 때문에 복합체 패턴을 이용해서 단계에 대한 정보를 저장하도록 제작해야함
8. 영역 판단을 하는데 유용한 널 반복자

### 중재자\(Mediator\)

한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의
객체들이 직접 서로를 참조하지 않도록 하여 객체 사이의 소결합을 촉진시키며, 개발자가 객체의 상호작용을 독립적으로 다양화시킬 수 있게 만듬

#### 활용성

다음의 경우에 사용
* 여러 객체가 잘 정의된 형태이기는 하지만 복잡한 상호작용을 가질 때
* 객체간의 의존성이 구조화되지 않으며, 잘 이해하기 어려울 때
* 한 객체가 다른 객체를 너무 많이 참조하고, 너무 많은 의사소통을 수행해서 그 객체를 재사용하기 힘들 때
* 여러 클래스에 분산된 행동들이 상속 없이 상황에 맞게 수정되어야 할 때

#### 결과

1. 서브클래싱을 제한
2. Colleague 객체 사이의 종속성을 줄임
3. 객체 프로토콜을 단순화함
4. 객체 간의 협력 방법을 추상화함
5. 통제가 집중화됨

#### 구현

중재자 패턴을 구현할 때 고려해야 할 이슈들
1. 추상 클래스인 Mediator 생략
2. 동료 객체-중재자 객체 간 의사소통

### 메멘토\(Memento\)

캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜 둠으로써, 이후 해당 객체가 그 상태로 되돌아올 수 있도록 함

#### 다른 이름

토큰(Token)

#### 활용성

다음의 경우 사용
* 어떤 객체의 상태에 대한 스냅샷(몇 개의 일부)을 저장한 후 나중에 이 상태로 복구해야 할 때
* 상태를 얻는 데 필요한 직접적인 인터페이스를 두면 그 객체의 구현 세부사항이 드러날 수밖에 없고, 이것으로 객체의 캡슐화가 깨질 때

#### 결과

1. 캡슐화된 경계를 유지 가능
2. Originator 클래스를 단순화할 수 있음
3. 메멘토의 사용으로 더 많은 비용이 들어갈 수도 있음
4. 제한 범위 인터페이스와 광범위 인터페이스를 정의해야 함
5. 메멘토를 관리하는 데 필요한 비용이 숨어있음

#### 구현

1. 서로 다른 정적 보호 정책을 지원할 수 있으므로 언어의 지원 여부를 잘 알아야함
2. 변경된 정보들만 계속 추가해나가는 점증적 상태 변경을 저장함

### 감시자\(Observer\)

객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 사애가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만듬

#### 다른 이름

종속자(Dependent), 게시-구독(Publish-Subscribe)

#### 활용성

사용하는 상황
* 어떤 추상 개념이 두 가지 양상을 갖고 하나가 다른 하나에 종속적일 때(각 양상을 별도의 객체로 캡슐화하여 이들 각각을 재사용할 수 있음)
* 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 프로그래머들은 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때
* 어떤 객체가 다른 객체에 자신의 변화를 통보할 수 있는데, 그 변화에 관심있어 하는 객체들이 누구인지에 대한 가정 없이도 그러한 통보가 될 때

#### 결과

1. Subject와 Observer 클래스 간에는 추상적인 결합도만이 존재
2. 브로드캐스터(broadcast) 방식의 교류를 가능하게 함
3. 예측하지 못한 정보를 갱신

#### 구현

1. 주체와 그것의 감시자를 대응시킴
2. 하나 이상의 주체를 감시
3. 누가 갱신을 호출시킬 것인가 결정
4. 주체의 삭제로 감시자가 무효 참조자를 갖게 되도록 만들면 안됨
5. 통보 전에 주체의 상태가 자체 일관성을 갖추도록 만들어야함
6. 감시자별 갱신 프로토콜을 피함
7. 자신이 관심 있는 변경이 무엇인지 명확하게 지정
8. 복잡한 갱신의 의미 구조를 캡슐화
9. Subject와 Observer 클래스를 합침

### 상태\(State\)

객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴
마치 자신의 클래스를 바꾸는 것처럼 보임

#### 다른 이름

상태 표현 객체(Object for State)

#### 활용성

* 객체의 행동이 상태에 따라 달라질 숭 ㅣㅆ고, 객체의 상태에 따라서 런타임에 행동이 바뀌어야 함
* 어떤 연산에 그 객체의 상태에 따라 달라지는 다중 분기 조건 처리가 너무 ㅁ낳이 들어 있을 때, 객체의 상태를 표현하기 위해 상태를 하나 이상의 나열형 상수로 정의해야 함

#### 결과

1. 상태에 따른 행동을 국소화하며, 서로 다른 상태에 대한 행동을 별도의 객체로 관리함
2. 상태 전이를 명확하게 만듬
3. 상태 객체는 공유될 수 있음

#### 구현

1. 상태 전이를 정하는 기준을 정해야 함
2. 테이블 기반의 대안
3. 상태 객체의 생성과 소멸
4. 동적 상속을 이용하는 방법

### 전략\(Strategy\)

동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만듬
알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 함

#### 다른 이름

정책(Policy)

#### 활용성

* 행동들이 조금씩 다를 뿐 개념적으로 관련된 많은 클래스들이 존재할 때
* 알고리즘의 변형이 필요할 때
* 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 때
* 하나의 클래스가 많은 행동을 정의하고, 이런 행동들이  그 클래스의 연산 안에서 복잡한 다중 조건문의 모습을 취할 떄

#### 결과

1. 동일 계열의 관련 알고리즘군이 생김
2. 서브클래싱을 사용하지 않는 대안
3. 조건문을 없앨 수 있음
4. 구현의 선택이 가능
5. 사용자(프로그램)는 서로 다른 전략을 알아야 함
6. Strategy 객체와 Context 객체 사이의 의사소통 오버헤드가 있음
7. 객체 수가 증가

#### 구현

1. Strategy 및 Context 인터페이스를 정의함
2. 전략을 템플릿 매개변수로 사용함
3. Strategy 객체에 선택성을 부여함

### 템플릿 메서드\(Template Method\)

객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룸
알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계 처리를 서브클래스에서 재정의할 수 있게 함

#### 활용성

* 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 때
* 서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때
* 서브클래스의 확장을 제어할 수 있음

#### 결과

한 개의 연산을 호출
* 구체 연산(concrete operation): ConcreteClass나 사용자 클래스에 정의된 연산
* AbstractClass 구체 연산: 서브클래스에서 일반적으로 유용한 연산
* 기본 연산: 추상화된 연산
* 팩토리 메서드
* **훅 연산**(hook operation): 필요하다면 서브클래스에서 확장할 수 있는 기본 행동을 제공하는 연산(기본적으로 아무 내용도 정의하지 않음)

#### 구현

1. C++의 접근 제한 방법을 이용함
2. 기본 연산의 수를 최소화함
3. 이름을 짓는 규칙을 만듬

### 방문자\(Visitor\)

객체 구조를 이루는 원소에 대해 수행할 연산을 표현
연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 함

#### 활용성

* 다른 인터페이스를 가진 클래스가 객체 구조에 포함되어 있으며, 구체 클래스에 따라 달라진 연산을 이들 클래스의 객체에 대해 수행하고자 할 때
* 각각 특징이 있고, 관련되지 않은 많은 연산이 한 객체 구조에 속해있는 객체들에 대해 수행될 필요가 있으며, 연산으로 클래스들을 "더럽히고" 싶지 않을 때
* 객체 구조를 정의한 클래스는 거의 변하지 않지만, 전체 구조에 걸쳐 새로운 연산을 추가하고 싶을 때

#### 결과

1. Visitor 클래스는 새로운 연산을 쉽게 추가함
2. 방문자를 통해 관련된 연산들을 한 군데로 모으고 관련되지 않은 연산을 떼어낼 수 있음
3. 새로운 ConcreteElement 클래스를 추가하기가 어려움
4. 클래스 계층 구조에 걸쳐서 방문
5. 상태를 누적할 수 있음
6. 데이터 은닉을 깰 수 있음

#### 구현

1. 이중 디스패치
2. 방문자는 각 객체 구조 요소를 방문해야함