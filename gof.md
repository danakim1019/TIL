# GoF의 디자인패턴

## 생성패턴

### 1. 추상 팩토리

#### 결과

1. 구체적인 클래스 분리
2. 제품군을 쉽게 대체 가능하도록 해줌
3. 제품 사이의 일관성 증진
4. 새로운 종류의 제품을 제공하기 어려움

#### 구현

1. 팩토리를 단일체로 정의
2. 제품을 생성
3. 확장 가능한 팩토리들을 정의

Kit 라는 접미어를 사용해서 추상 팩토리 클래스임을 표시

### 2. 빌더

#### 결과

1. 제품에 대한 내부 표현을 다양하게 변화할 수 있음
2. 생성과 표현에 필요한 코드를 분리
3. 복합 객체를 생성하는 절차를 좀더 세밀하게 나눌 수 있음

#### 구현

1. 조합과 구축에 필요한 인터페이스 정의
2. 제품에 대한 추상 클래스는 필요 없음
3. Builder에 있는 메서드에 대해서는 구현을 제공하지 않는게 일반적

### 3. 팩토리 메서드

#### 결과

1. 서브클래스에 대  훅\(hook\) 메서드를 제공
2. 병렬적인 클래스 계통을 연결하는 역할 담당

#### 구현

1. 구현 방법이 크게 두 가지
   1. Creator 클래스를 추상 클래스로 정의하고 정의한 팩토리 메서드에 대한 구현은 제공하지 않는 경우
   2. Creator가 구체 클래스이고 팩토리 메서드에 대한 기본 구현을 제공하는 경우
2. 팩토리 메서드를 매개변수화함
3. 언어마다 구현 방법이 조금 다를 수 있음
4. 템플릿을 사용하여 서브클래싱을 피함

다른 이름은 가상 생성자\(Virtual Constructor\)

### 4. 원형

원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체 생성

#### 결과

1. 런타임에 새로운 제품을 추가하고 삭제 가능
2. 값들을 다양화함으로써 새로운 객체를 명세
3. 구조를 다양화함으로써 새로운 객체를 명세
4. 서브클래스의 수를 줄임
5. 동적으로 클래스에 따라 응용프로그램을 설정할 수 있음

#### 구현

1. 원형 관리자를 사용
2. Clone\(\) 연산을 구현
3. Clone을 초기화

### 5. 단일체\(Singleton\)

오직 한 개의 클래스 인스턴스만을 갖도록 보장 및 전역적인 접근점을 제공

#### 결과

1. 유일하게 존재하는 인스턴스로의 접근을 통제
2. 이름 공간\(name space\)을 좁힘
3. 연산 및 표현의 정제를 허용
4. 인스턴스의 개수를 변경하기 자유로움
5. 클래스 연산을 사용하는 것보다 훨씬 유연한 방법

#### 구현

1. 인스턴스가 유일해야 함을 보장
2. Singleton 클래스를 서브클래싱함

## 구조패턴

### 1. 적응자\(Adapter\)

클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킴

서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킴

#### 고려해야할 추가 사항들

1. Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되는지
2. 대체 가능\(Pluggable\) 적응자
3. 양방향 적응자를 통한 투명성 제공

#### 구

1. 클래스 적응자를 C++로 구현
2. 대체 가능 적응자
   1. 추상 연산을 사용하는 방법
   2. 위임 객체를 사용하는 방법
   3. 매개변수화된 적응자를 사용하는 방

### 가교\(Bridge\)

#### 다른 이름

핸들/구현부\(Handle/Body\)

#### 결과

1. 인터페이스와 구현 분리
2. Abstraction과 Implementor를 독립적으로 확장 가능
3. 구현 세부 사항을 사용자에게서 숨기기

#### 구현

1. Implementor 하나만 둔다
2. 정확한 Implementor 객체를 생성
3. Implementor를 공
4. 다중 상속을 이용

### 복합체

부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성

사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

#### 결과

1. 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의
2. 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문에 사용자 코드가 단순해짐
3. 새로운 종류의 구성요소를 쉽게 추가 가능
4. 설계가 지나치게 범용성을 많이 가짐

#### 구현

1. 포함 객체에 대한 명확한 참조자
2. 구성요소 공유
3. Component 인터페이스를 최대화
4. 자식을 관리하는 연산 선언
5. Component가 Component의 리스트를 구현\(자식의 개수가 어느 정도 될 떄만 가치를 지님\)
6. 자식 사이의 순서 정하기
7. 성능 개선을 위한 캐싱\(caching\)
8. 구성요소를 삭제하는 책임\(가비지 컬렉션의 기능을 제공하지 않는 경우 Composite클래스가 책임\)
9. 구성요소를 저장하기 위한 가장 적당한 데이터 구조는 효율적인 데이터 구조를 선택

### 장식자\(Decorator\)

#### 다른 이름

랩퍼\(Wrapper\)

#### 활용성

* 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가하기 위해 사용
* 제거될 수 있는 책임에 대해 사용
* 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용

#### 결과

1. 단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있음
2. 클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있음
3. 장식자와 해당 그 장식자의 구성요소가 동일한 것은 아님
4. 장식자를 사용함으로써 작은 규모의 객체들이 많이 생김

#### 구현

1. 인터페이스 일치
2. 추상 클래스로 정의되는 Decorator 클래스 생략
3. Component 클래스는 가벼운 무게 유지
4. 객체의 겉포장을 변경할지 속을 변경할지 선택

### 퍼사드\(Facade\)

한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴

서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의

#### 결과

1. 서브시스템의 구성요소를 보호할 수 있음
2. 서브 시스템과 사용자 코드 간의 결합도를 더욱 약하게 만듬
3. 응용프로그램 쪽에서 서브 시스템 클래스를 사용하는 것을 완전히 막지는 않아서 Facade를 사용할지 서브시스템 클래스를 직접 사용할지 결정 가능

#### 구현

1. 사용자와 서브시스템 간의 결합도 줄이기
2. 서브시스템 클래스 중 공개할 것과 감출 것을 정의

### 플라이급\(Flyweight\)

공유를 통해 많은 수의 소립 객체들을 효과적으로 지원

#### 활용성

* 응용프로그램이 대량의 객체를 사용해야 할 때
* 객체의 수가 너무 많아져서 저장 비용이 너무 높아질 때
* 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
* 부가적인 속성들을 제거한 후 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 때
* 본질이 달랐던 것은 아닐 때(부가적인 속성 때문에 다른 객체로 간주한 경우)
* 응용 프로그램이 객체의 정체성에 의존하지 않을 때

#### 결과

1. 공유해야 하는 인스턴스의 전체 수를 줄일 수 있음
2. 객체별 본질적 상태의 양을 줄일 수 있음
3. 부가적인 상태는 연산되거나 저장될 수 있음

#### 구현

1. 부가적인 상태를 제외
2. 공유할 객체를 관리

### 프록시\(Proxy\)

다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둠

#### 다른 이름

대리자(Surrogate)

#### 활용성

1. 원격지 프록시
2. 가상 프록시
3. 보호용 프록시
4. 스마트 참조자(스마트 포인터)

#### 결과

1. 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있음
2. 가상 프록시는 요구에 따라 객체를 생성하는 등 처리를 최적화 가능
3. 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임짐

#### 구현

1. C++에서는 멤버 접근 연산자를 오버로드
2. 스몰토크에 정의된 doesNotUnderstand를 사용하는 방법
3. Proxy가 항상 자신이 상대할 실제 대상을 알 필요는 없음(단, RealSubject의 인스턴스를 생성해야하는 시점에는 어떤 클래스의 인스턴스를 생성해야하는지 알아야함)

## 행동 패턴

어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은가, 알고리즘을 어느 객체에 정의하는 것이 좋은가 등을 다룸

### 책임 연쇄\(Chain of responsibility\)

메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴

### 활용성

* 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤것이 선행자인지 모를 때, 처리자가 자동으로 확정되어야 함
* 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
* 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

### 결과

1. 객체 간의 행동적 결합도가 적어짐
2. 객체에게 책임을 할당하는 데 유연성을 높일 수 있음
3. 메시지 수신이 보장되지는 않음

### 구현

1. 후속 처리자들의 연결 고리 구현하기
2. 후속 처리자 연결하기
3. 처리 요청의 표현부를 정의함
4. 스몰토크를 쓸 때 자동 전달 기능을 이용함