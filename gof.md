# GoF의 디자인패턴

## 생성패턴

### 1. 추상 팩토리

#### 결과

1. 구체적인 클래스 분리
2. 제품군을 쉽게 대체 가능하도록 해줌
3. 제품 사이의 일관성 증진
4. 새로운 종류의 제품을 제공하기 어려움

#### 구현

1. 팩토리를 단일체로 정의
2. 제품을 생성
3. 확장 가능한 팩토리들을 정의

Kit 라는 접미어를 사용해서 추상 팩토리 클래스임을 표시

### 2. 빌더

#### 결과

1. 제품에 대한 내부 표현을 다양하게 변화할 수 있음
2. 생성과 표현에 필요한 코드를 분리
3. 복합 객체를 생성하는 절차를 좀더 세밀하게 나눌 수 있음

#### 구현

1. 조합과 구축에 필요한 인터페이스 정의
2. 제품에 대한 추상 클래스는 필요 없음
3. Builder에 있는 메서드에 대해서는 구현을 제공하지 않는게 일반적

### 3. 팩토리 메서드

#### 결과

1. 서브클래스에 대  훅\(hook\) 메서드를 제공
2. 병렬적인 클래스 계통을 연결하는 역할 담당

#### 구현

1. 구현 방법이 크게 두 가지
   1. Creator 클래스를 추상 클래스로 정의하고 정의한 팩토리 메서드에 대한 구현은 제공하지 않는 경우
   2. Creator가 구체 클래스이고 팩토리 메서드에 대한 기본 구현을 제공하는 경우
2. 팩토리 메서드를 매개변수화함
3. 언어마다 구현 방법이 조금 다를 수 있음
4. 템플릿을 사용하여 서브클래싱을 피함

다른 이름은 가상 생성자\(Virtual Constructor\)

### 4. 원형

원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체 생성

#### 결과

1. 런타임에 새로운 제품을 추가하고 삭제 가능
2. 값들을 다양화함으로써 새로운 객체를 명세
3. 구조를 다양화함으로써 새로운 객체를 명세
4. 서브클래스의 수를 줄임
5. 동적으로 클래스에 따라 응용프로그램을 설정할 수 있음

#### 구현

1. 원형 관리자를 사용
2. Clone\(\) 연산을 구현
3. Clone을 초기화

### 5. 단일체\(Singleton\)

오직 한 개의 클래스 인스턴스만을 갖도록 보장 및 전역적인 접근점을 제공

#### 결과

1. 유일하게 존재하는 인스턴스로의 접근을 통제
2. 이름 공간\(name space\)을 좁힘
3. 연산 및 표현의 정제를 허용
4. 인스턴스의 개수를 변경하기 자유로움
5. 클래스 연산을 사용하는 것보다 훨씬 유연한 방법

#### 구현

1. 인스턴스가 유일해야 함을 보장
2. Singleton 클래스를 서브클래싱함

## 구조패턴

### 1. 적응자\(Adapter\)

클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킴

서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킴

#### 고려해야할 추가 사항들

1. Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되는지
2. 대체 가능\(Pluggable\) 적응자
3. 양방향 적응자를 통한 투명성 제공

#### 구

1. 클래스 적응자를 C++로 구현
2. 대체 가능 적응자
   1. 추상 연산을 사용하는 방법
   2. 위임 객체를 사용하는 방법
   3. 매개변수화된 적응자를 사용하는 방

### 가교\(Bridge\)

#### 다른 이름

핸들/구현부\(Handle/Body\)

#### 결과

1. 인터페이스와 구현 분리
2. Abstraction과 Implementor를 독립적으로 확장 가능
3. 구현 세부 사항을 사용자에게서 숨기기

#### 구현

1. Implementor 하나만 둔다
2. 정확한 Implementor 객체를 생성
3. Implementor를 공
4. 다중 상속을 이용

### 복합체

부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성

사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

#### 결과

1. 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의
2. 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문에 사용자 코드가 단순해짐
3. 새로운 종류의 구성요소를 쉽게 추가 가능
4. 설계가 지나치게 범용성을 많이 가짐

#### 구현

1. 포함 객체에 대한 명확한 참조자
2. 구성요소 공유
3. Component 인터페이스를 최대화
4. 자식을 관리하는 연산 선언
5. Component가 Component의 리스트를 구현\(자식의 개수가 어느 정도 될 떄만 가치를 지님\)
6. 자식 사이의 순서 정하기
7. 성능 개선을 위한 캐싱\(caching\)
8. 구성요소를 삭제하는 책임\(가비지 컬렉션의 기능을 제공하지 않는 경우 Composite클래스가 책임\)
9. 구성요소를 저장하기 위한 가장 적당한 데이터 구조는 효율적인 데이터 구조를 선택

### 장식자\(Decorator\)

#### 다른 이름

랩퍼\(Wrapper\)

#### 활용성

* 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가하기 위해 사용
* 제거될 수 있는 책임에 대해 사용
* 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용

#### 결과

1. 단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있음
2. 클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있음
3. 장식자와 해당 그 장식자의 구성요소가 동일한 것은 아님
4. 장식자를 사용함으로써 작은 규모의 객체들이 많이 생김

#### 구현

1. 인터페이스 일치
2. 추상 클래스로 정의되는 Decorator 클래스 생략
3. Component 클래스는 가벼운 무게 유지
4. 객체의 겉포장을 변경할지 속을 변경할지 선택

